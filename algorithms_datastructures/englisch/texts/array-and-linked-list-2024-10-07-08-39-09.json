{
    "ID": 392861,
    "post_author": "909",
    "post_date": "2024-05-03 11:59:00",
    "post_date_gmt": "2024-05-03 09:59:00",
    "post_content": "<!-- wp:paragraph -->\n<p>Duration: approx. 45 minutes <\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>In the previous text lesson, we saw that data structures can be categorized into sequential structures and set structures. In this lesson, we will look at a scenario that requires a sequential data structure. This means that the data structure should manage our data in a fixed order. We will take a closer look at two examples and think about how suitable both structures are for our scenario: the array and the linked list. After this lesson, you will be able to:<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:list -->\n<ul><li>explain how the array and linked list are organized on the memory,<\/li><li>determine the time complexities for important methods in both data structures,<\/li><li><em>use data structure augmentation<\/em>,<em> <\/em>to improve the time complexities of methods.<\/li><\/ul>\n<!-- \/wp:list -->\n\n<!-- wp:html -->\n[sf_box type=\"szenario\"]\n\nAt a small online retail company, incoming orders are processed successively. When an order is received, it is placed in a queue. If the order changes to processing status, it is removed from the queue and moved to a processing system. Management asks you to develop code for the queue. \n\n\n[\/sf_box]\n<!-- \/wp:html -->\n\n<!-- wp:paragraph -->\n<p><\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Before we can translate our problem into code, we should think about the right data structure. How would you implement the queue? It should essentially be able to do two things:<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:list {\"ordered\":true,\"type\":\"1\"} -->\n<ol type=\"1\"><li>If an order is received, an element is inserted at the end.<\/li><li>If an order changes to processing status, it is removed from the front.<\/li><\/ol>\n<!-- \/wp:list -->\n\n<!-- wp:paragraph -->\n<p>The quality of our data structure is measured by the time complexity of these two tasks. We will call the associated methods <code>insert_last()<\/code> and <code>delete_first()<\/code>, regardless of the data structure selected.<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:heading -->\n<h2>The queue as an array<\/h2>\n<!-- \/wp:heading -->\n\n<!-- wp:paragraph -->\n<p>An obvious solution is to create the queue as a Python list. Using <code>append()<\/code> we can insert orders at the end and remove them from the beginning using <code>pop(0)<\/code>. We could save the orders as a Python dictionary, which can contain the order number, date, order volume, payment method and other information.<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Our data structure with the <code>insert_last()<\/code> and <code>delete_first()<\/code> methods could look like this: &nbsp;<\/p>\n<!-- \/wp:paragraph -->\n\n<pre class=\"language-python\"><code>class Queue: \n    def __init__(self): \n        self.queue = []\n\n    def insert_last(self, data): \n        assert isinstance(data, dict)\n        self.queue.append(data)\n\n    def delete_first(self): \n        if len(self.queue) &gt;= 1:\n            self.queue.pop(0) \n        else: \n            print('Empty queue')<\/code><\/pre>\n\n<!-- wp:paragraph -->\n<p>Is <code>Queue<\/code> a good implementation for a queue? A data structure's suitability is determined by how high the time complexities of the frequently used methods are. In the following, we always consider the worst case, which is described by with big O notation.<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>What are the time complexities of <code>insert_last()<\/code> and <code>delete_first()<\/code> in <code>Queue<\/code>? To answer these questions, we need to know how <code>list<\/code> works behind the scenes. What happens when we use <code>append()<\/code> and <code>pop(0)<\/code>?<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>In Python, the <code>list<\/code> data type is created as an array. A specific space in the memory is reserved for the array. Its elements are created as a contiguous block without interruptions or gaps. The first element is assigned a so-called <em>base address<\/em>. This contains the index position 0. A certain amount of space is reserved for each element. If we count the length of this space to the right of the base address, we end up at index position 1, if we then count the length of a space to the right again, we end up at index position 2 and so on. Because the storage location of each element is predictable, it is possible to access elements in a list using the index position in <em>O(1)<\/em>. This is one of the biggest advantages of the array.<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>We can imagine the array for our queue example as follows: &nbsp;&nbsp;<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:html -->\n<a class=\"lightbox\" href=\"\/training-content\/python-programmer\/module-05\/chapter-01\/images\/pyp_ads_t4_array.png\"><img src=\"\/training-content\/python-programmer\/module-05\/chapter-01\/images\/pyp_ads_t4_array.png\"><\/a>\n<!-- \/wp:html -->\n\n<!-- wp:paragraph {\"fontSize\":\"small\"} -->\n<p class=\"has-small-font-size\"><strong>Figure 1<\/strong>: The array<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>We had defined the orders in <code>Queue<\/code> as a <code>dict<\/code>. Here, for the sake of simplicity, we only display them as order numbers. &nbsp;<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:html -->\n[sf_box type=\"vertiefung\"]\n<details>\n<summary>\n<strong>Deep dive<\/strong>: Dynamic adjustments in the array\n<\/summary>\nWhat happens when the reserved block is full? In Python, a list can always be extended. A new block with more space is then freed up, and all elements are copied into it. If it is foreseeable that the reserved space will not be needed, the elements are moved to a smaller block in the same way. \n\n<\/details>\n\n\n[\/sf_box]\n<!-- \/wp:html -->\n\n<!-- wp:paragraph -->\n<p><\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:heading -->\n<h2>Removing the first element from the array<\/h2>\n<!-- \/wp:heading -->\n\n<!-- wp:paragraph -->\n<p>What is the time efficiency of <code>delete_first()<\/code> in <code>Queue<\/code>? If an order changes to processing status, the method removes it from our queue using the list method <code>pop(0)<\/code>. The time complexities of <code>delete_first()<\/code> and <code>pop(0)<\/code> are therefore identical.<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Can you already guess which operations the list method <code> pop(0)<\/code> performs in the background? Try to answer the following question before you continue reading. &nbsp;<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:shortcode -->\n[sf_quiz id=387622]\n<!-- \/wp:shortcode -->\n\n<!-- wp:paragraph {\"textColor\":\"black\"} -->\n<p class=\"has-black-color has-text-color\">If an element is removed from an array, all subsequent elements must be moved one place to the left. If the first element is removed, <strong>all <\/strong>remaining elements are moved. In our queue, we can imagine it like this:<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:html -->\n<img class=\"lightbox\" src=\"\/training-content\/python-programmer\/module-05\/chapter-01\/images\/pyp_ads_t4_array_deletion.gif\">\n<!-- \/wp:html -->\n\n<!-- wp:paragraph {\"fontSize\":\"small\"} -->\n<p class=\"has-small-font-size\"><strong>Figure 2:<\/strong> The first order is removed from the array.<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The first order is therefore removed first. The second order then moves to index position 0, which is now free, then the third order moves to index position 1, and so on. Because this operation is carried out for all orders in the queue, <code>pop(0)<\/code> and therefore also <code>delete_first()<\/code> in <code>Queue<\/code> has a linear time complexity, <em>O(n)<\/em>. &nbsp;&nbsp;&nbsp;<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>That's not particularly fast. Can a linked list solve this better? First, let's take another look at how a linked list is arranged in the memory.<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:heading -->\n<h2>Linked<em> <\/em>List<\/h2>\n<!-- \/wp:heading -->\n\n<!-- wp:paragraph -->\n<p>A linked list works slightly differently to an array: it is a pointer-based data structure. Instead of keeping memory space free for the entire queue, each job now has its own space in the memory. In addition to the actual information about the order, we store a pointer to the next order in each element of the linked list. The data structure is kept using these pointers and its elements are given a sequence.<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>As in the array, the data structure also receives a base address here. It's the memory address of the first element of the linked list, also referred to as <em>head<\/em>. <\/em>Alternatively, we can also say that our linked list structure has a <em>head<\/em>-pointer to the first element. So when we talk about pointers in a linked list, we distinguish between the <em> <strong>head<\/strong><\/em><strong>-pointer<\/strong> of the linked list and the <strong><em>next<\/em>-pointers<\/strong> of the individual elements. The following figure illustrates the structure of a linked list.<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:html -->\n<a class=\"lightbox\" href=\"\/training-content\/python-programmer\/module-05\/chapter-01\/images\/pyp_ads_t4_linked_list.png\"><img src=\"\/training-content\/python-programmer\/module-05\/chapter-01\/images\/pyp_ads_t4_linked_list.png\"><\/a>\n<!-- \/wp:html -->\n\n<!-- wp:paragraph {\"fontSize\":\"small\"} -->\n<p class=\"has-small-font-size\"><strong>Figure 3<\/strong>: Linked List<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>In this text lesson, we will not yet look at any code for the linked list. Instead, we want to give a few conceptual thoughts about this data structure. We will then implement it in the next exercise.<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>It may be helpful to keep the basic structure in mind. The data structure itself is represented by a class <code>LLQueue<\/code>. In it, we create the <em>head<\/em>-pointer as an attribute. An order is an object of the <code>LinkedNode<\/code> class. The <em>next<\/em>-pointer is an attribute of this class. Our main objective is to create two methods in <code>LLQueue<\/code>: incoming orders are appended using <code>insert_last()<\/code>, orders that change to processing status are removed from the front of the queue using <code>delete_first()<\/code>. The time complexity of both methods should be as low as possible. &nbsp;&nbsp;<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:heading -->\n<h2>Removing the first element from the linked list<\/h2>\n<!-- \/wp:heading -->\n\n<!-- wp:paragraph -->\n<p>If an order changes to the processing status, this was not possible very quickly with a linear runtime in our array structure. In this section, we will explore whether the linked list is better suited to this task. &nbsp;<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The first order in our queue is one which the head-pointer points to. What do we have to do to remove the first order? Again, try to answer the question before you continue reading.<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:shortcode -->\n[sf_quiz id=387623]\n<!-- \/wp:shortcode -->\n\n<!-- wp:paragraph -->\n<p>To remove the first order, we simply have to reset the <em>head<\/em>-pointer. If it now points to the original second order, this automatically moves to the first position. The original first order is then no longer linked to our data structure. The illustration shows the process.<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:html -->\n<a class=\"lightbox\" href=\"\/training-content\/python-programmer\/module-05\/chapter-01\/images\/pyp_ads_t4_linked_list_deletion.gif\"><img src=\"\/training-content\/python-programmer\/module-05\/chapter-01\/images\/pyp_ads_t4_linked_list_deletion.gif\"><\/a>\n<!-- \/wp:html -->\n\n<!-- wp:paragraph {\"fontSize\":\"small\"} -->\n<p class=\"has-small-font-size\"><strong>Figure 4:<\/strong> The first element is deleted from the list. <\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The number of operations required to reset the <em>head<\/em>-pointer is completely independent of the number of jobs in the queue. This makes it possible to remove the first order in the linked list with a constant runtime. It couldn't be better! The linked list is clearly better suited to this task than the array.<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>However, in our queue, newly received orders must also be appended to the end. How quickly can the linked list complete this task?<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:heading -->\n<h2>Appending an element to the end of the linked list<\/h2>\n<!-- \/wp:heading -->\n\n<!-- wp:paragraph -->\n<p>If we want to add a new incoming order to our queue, we have to do two things: We have to find the previous last order and link it to the new order using a <em>next<\/em>-pointer. In the next question, you should answer how quickly the last order can be found. Assume that the linked list is structured exactly as shown in the figure above: The structure itself has a <em>head<\/em>-pointer to the first element and each element has a <em>next<\/em>-pointer to the following element.<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:shortcode -->\n[sf_quiz id=387873]\n<!-- \/wp:shortcode -->\n\n<!-- wp:paragraph -->\n<p>Here we run into one of the fundamental disadvantages of the linked list: in order to <strong>find<\/strong> the last element, we have to iterate through our entire queue, starting with the first order. Otherwise, we do not know where in the memory this order is located. If our queue is very long, this could take some time! &nbsp;<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>How fast is the appending a new incoming order then? For the next question, assume that our <code>insert_last()<\/code> method includes both finding and removing.<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:shortcode -->\n[sf_quiz id=387621]\n<!-- \/wp:shortcode -->\n\n<!-- wp:paragraph -->\n<p>Even if the removal itself only requires a constant runtime, finding the last entry dominates the entire process. The runtime of <code>my_llqueue.insert_last()<\/code> is therefore not really satisfactory. However: it is our data structure, and nobody is telling us that we have to follow a predefined schema. We are allowed to modify our linked list. Do you have any ideas on how we can make our method faster?&nbsp;<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Question<\/strong>: How can <code>insert_last()<\/code> be implemented in <em>O(1)<\/em>? <\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:html -->\n[sf_box type=\"vertiefung\"]\n<details>\n<summary>\nSolution (click to open)\n<\/summary>\nSo far, the data structure has a <i>head<\/i>-pointer to the first element. Similarly, a <i>tail<\/i>-pointer could point to the last element. This makes it possible to access the last element directly. The <code>insert_last()<\/code> method then links the previous last order with the new order and adjusts the <i>tail<\/i>-pointer accordingly.  \n\n<\/details>\n[\/sf_box]\n<!-- \/wp:html -->\n\n<!-- wp:paragraph -->\n<p><\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Did you find the solution? Then you have used a technique that plays a major role in data structures: <em>data structure augmentation. <\/em>It is often used to make code more efficient. Here we introduced the <em>tail<\/em>-pointer as an additional attribute in our data structure <code>LLQueue<\/code>. This means we no longer have to iterate through the entire data structure. The tradeoff: We need a little more memory and have to update the <em>tail-<\/em>-pointer as soon as we add a new job to our queue.<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:html \/-->\n\n<!-- wp:paragraph -->\n<p>It's always worth considering whether <em>data structure augmentation<\/em> is worthwhile: Does the additional attribute require a huge amount of updating? If so, the improved time complexity is cancelled out. It is also possible that the memory requirements will increase, negating the advantages. For the intended <em>tail<\/em>-pointer, we do not have to worry about updating or increased memory requirements: The update only needs to be carried out for the most recent job, and the additional storage space required is also very small. So, the advantages of the <em>tail<\/em>-pointer are in no way outweighed by the increased requirements. So remember: if we introduce the <em>tail<\/em>-pointer as an additional attribute in our data structure, it is also possible to append orders to the end of our queue with a constant runtime.<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:html -->\n[sf_box type=\"vertiefung\"]\n<details>\n<summary>\n<strong>Deep dive<\/strong>: Big O for storage space. \n<\/summary>\n\nWe have already seen that the concept of efficiency also includes memory requirements in addition to runtime. Just like big O notation for time complexity, there is also big O notation for memory complexity. <i>O(1)<\/i> means that the required memory space of a program\/method is independent of the input size <i>n<\/i>. If the memory space increases linearly, the complexity is <i>O(n)<\/i>. Placing a job in the queue has a storage space complexity of <i>O(1)<\/i> both in an array and in a linked list. If we place <i>n<\/i> orders in the queue, the storage space complexity for this is <i>O(n)<\/i>. \n<\/details>\n[\/sf_box]\n<!-- \/wp:html -->\n\n<!-- wp:paragraph -->\n<p><\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:heading -->\n<h2>Appending an element to the end of the array<\/h2>\n<!-- \/wp:heading -->\n\n<!-- wp:paragraph -->\n<p>We already know that the linked list is superior to the array in our queue example, because it can do both with a constant time complexity: remove orders from the beginning and append them to the end. The array, on the other hand, requires a linear runtime to remove orders from the beginning. For the sake of being thorough, let's also consider how efficiently the array can append orders to the end. &nbsp;&nbsp;<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Remember briefly how the Python list or array works: the reserved memory space in the array is usually not fully utilized. If we want to append an element to the end of a Python list, we need to know how many spaces are already occupied. We could iterate through the array to do this. However, this is again only possible in linear runtime. So, a data structure augmentation is a good idea: an attribute <em><code>length<\/code><\/em> makes appending an order to the end of the queue faster.<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>In general, the <code>len()<\/code> list method is essential in Python. It is used frequently and for many other methods. The additional attribute is therefore worthwhile. You should now be able to answer the following question:<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:shortcode -->\n[sf_quiz id=387874]\n<!-- \/wp:shortcode -->\n\n<!-- wp:paragraph -->\n<p>So let's summarize: a modified version of the linked list is ideal for our queue example, because both key methods can be implemented in constant runtime. An array structure can handle the appending of new incoming orders to the end of the queue well. However, removing orders from the beginning is only possible in linear runtime. &nbsp;&nbsp;<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:shortcode \/-->\n\n<!-- wp:html -->\n[sf_box type=\"vertiefung\"]\n<details>\n<summary>\n<strong>Deep dive<\/strong>: FIFO, LIFO, queue and stack.\n<\/summary>\n\nThe queue is a common illustration of the advantages of the linked list. Because it is extended using the <i>tail<\/i>-pointer, it is sometimes referred to as a data structure itself. Common expressions for this are <i>FIFO (First-In-First-Out)<\/i> or <i>queue<\/i>.  The counterpart to this is the <i>LIFO (Last-In-First-Out)<\/i> structure, in which the most recently received data is removed first. <i>LIFO<\/i> is also referred to as a <i>stack<\/i>. The terms <i>LIFO<\/i> and <i>FIFO<\/i> are commonly used in IT as well as in warehousing and accounting.  \n\n<\/details>\n[\/sf_box]\n<!-- \/wp:html -->\n\n<!-- wp:paragraph -->\n<p><\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>You decide to implement the queue for the online mail order company as a linked list. You will do this in the next exercise.<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:html -->\n[sf_box type=\"merke\"]\n<strong>Remember:<\/strong>\n<ul>\n \t<li> The linked list is ideal for the requirements of a queue. <\/li>\n \t<li> It should then have a <i>tail<\/i>-pointer as well as the <i>head<\/i>-pointer. <\/li>\n \t<li> Data structures can sometimes be designed more efficiently with <i>data structure augmentation<\/i>.<\/li>\n<\/ul>\n[\/sf_box]\n<!-- \/wp:html -->",
    "post_title": "Array and Linked List",
    "post_excerpt": "",
    "post_status": "publish",
    "comment_status": "closed",
    "ping_status": "closed",
    "post_password": "",
    "post_name": "array-and-linked-list",
    "to_ping": "",
    "pinged": "",
    "post_modified": "2024-05-03 11:57:00",
    "post_modified_gmt": "2024-05-03 09:57:00",
    "post_content_filtered": "",
    "post_parent": 392855,
    "guid": "https:\/\/datalab.stackfuel.com\/?post_type=item&#038;p=392861",
    "menu_order": 36,
    "post_type": "item",
    "post_mime_type": "",
    "comment_count": "0",
    "filter": "raw",
    "meta": {
        "sf_item_type": "lecture",
        "_edit_lock": "1728290322:4236",
        "_edit_last": "909",
        "sf_lecture_type": "text",
        "sf_invisibility_setting": "0",
        "sf_training_duration": null
    }
}