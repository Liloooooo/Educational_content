{
    "ID": 392857,
    "post_author": "909",
    "post_date": "2024-05-03 06:00:00",
    "post_date_gmt": "2024-05-03 04:00:00",
    "post_content": "<!-- wp:paragraph -->\n<p>Duration: approx. 10 minutes<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><em>\"An algorithm is the most powerful weapon you can use to tame the complexity that underlies almost everything.\" <\/em>- Robert Sedgewick<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Algorithms are everywhere: search engines use them to show us the most suitable results, navigation apps use them to find the quickest route to our destination, and social media uses them to show us entries that match our interests or suggest suitable contacts. The term from computer science has now entered everyday language. But what exactly does the term algorithm mean? &nbsp;&nbsp;&nbsp;<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:heading -->\n<h2>An algorithm is a clearly defined instruction for action<\/h2>\n<!-- \/wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Roughly speaking, an algorithm is a set of instructions for solving a problem. It can be implemented as a computer program or written in human language and executed by humans. By executing it, we should get the correct results. We will refrain from a strict mathematical definition here, as that is quite abstract. However, for us to call an instruction an algorithm, it should fulfill the following criteria as a minimum:<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:list -->\n<ul><li>The steps of the instruction must be clearly describable in a <strong>finite text<\/strong>.<\/li><li>Each step must actually<strong> be executable<\/strong><\/li><li>The instruction must only<strong> require a finite number of steps<\/strong> for execution.<\/li><li>The instruction must manage with <strong>finite memory<\/strong>.<\/li><\/ul>\n<!-- \/wp:list -->\n\n<!-- wp:paragraph -->\n<p>Let's take a look at an example: Suppose we want to find a specific book title in an unsorted library with a single shelf. In the library, the books are left-aligned and there are no gaps between the books. We could proceed as follows:<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:list {\"ordered\":true,\"type\":\"1\"} -->\n<ol type=\"1\"><li>Start the search on the far left of the shelf.<\/li><li>If there is no book in the position, end the search and report that the title you are looking for was not found.<\/li><li>If there is a book in the position, look at the title of the book. If the title matches the one you are looking for, enter the book and its position and end the search.<\/li><li>Move one position to the right and repeat all the steps from step 2.<\/li><\/ol>\n<!-- \/wp:list -->\n\n<!-- wp:paragraph -->\n<p>Here we are looking at an action rule which, if available, gives us the correct book title. Does it fulfill the above criteria?<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The <strong>descriptive text is obviously finite<\/strong>, because it can be described by steps 1) - 4). Each <strong>step is executable<\/strong> and could be implemented by another person<\/strong>. <\/strong>The required<strong> memory space is finite. <\/strong>A person only has to remember where they are currently searching and what the title they are looking for is. They don't even have to remember which titles they have already seen. The memory required is therefore very limited compared to many other tasks. If the algorithm was executed by a computer, \"limited memory\" would mean that it can be completed with a fixed amount of resources, i.e. RAM memory used or other storage resources. Finally, the process only requires<strong> a finite number of steps<\/strong>: The search will never take an infinite amount of time. There is a finite number of books on the shelf. As soon as all the books have been checked or the book you are looking for has been found, the process ends.<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>So, our instruction meets the minimum criteria for algorithms. Now it's your turn. Answer the following task by looking for an instruction that does not fulfill at least one of the criteria. You will find a possible solution in the following drop-down box.<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:html -->\n<p><strong>Task:<\/strong> Describe the search for a book title in a non-algorithmic way.<\/p>\n\n<p>[sf_box type=\"vertiefung\"]<\/p>\n\n<details>\n<summary>Possible solution<\/summary>\n<ol>\n<li>Take a book at random from the shelf<\/li>\n<li>If the title matches the one you are looking for, output the book and end the search<\/li>\n<li>Otherwise, repeat the steps starting with step 1<\/li>\n<\/ol>\n<p>Executing these instructions would have a potentially infinite number of steps. If the book is not found, there is no mechanism to end the process. It is potentially infinite even if the title is available on the shelf. Have you found another solution? Then feel free to post it in the forum!<\/p>\n\n<\/details>\n[\/sf_box]\n<!-- \/wp:html -->\n\n<!-- wp:columns -->\n<div class=\"wp-block-columns\"><!-- wp:column {\"width\":\"100%\"} -->\n<div class=\"wp-block-column\" style=\"flex-basis:100%\"><!-- wp:paragraph -->\n<p><\/p>\n<!-- \/wp:paragraph --><\/div>\n<!-- \/wp:column --><\/div>\n<!-- \/wp:columns -->\n\n<!-- wp:heading -->\n<h2>We need an objective measure to measure efficiency<\/h2>\n<!-- \/wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Our example algorithm provides us with correct results and meets the minimum criteria for algorithms. However, we have not yet addressed one important question in our considerations: Is the algorithm the best possible algorithm? This leads to the next question: What makes one algorithm better than another? If an algorithm produces results quickly, this is definitely a desirable property. So let's talk about the algorithm's <strong>runtime<\/strong>.<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>But why should we worry about the runtime? Aren't computers so fast these days that the path to the destination is of secondary importance? Not quite, because the amount of data being processed is also getting bigger and bigger.<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>In 2021, there were around 130 trillion (130,000,000,000,000) websites on the internet. Imagine if Google's algorithm crawled each of these websites in turn for every search query. If it took even a hundredth of a millisecond to check a single page, we would have to wait more than 41 years for our result! An algorithm like this would be completely useless. It is not only important that an algorithm solves a problem, it must also do so in an acceptable amount of time.<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:html -->\n<p>[sf_box type=\"vertiefung\"]<\/p>\n\n<details>\n<summary>Deep Dive: Two aspects of efficiency: runtime and storage space requirements. <\/summary>\n\n<p>When we talk about the efficiency of an algorithm, we usually refer to its runtime. But there is something else - how much memory does it need to run? Let's take our book search example. If the person running the algorithm had to remember not only the current position, but also the titles they had already viewed, their memory would be put under greater strain. In other words, the memory requirement would increase. An algorithm like this would have a lower memory efficiency.<\/p>\n<p>When evaluating algorithms, the focus in the vast majority of applications is on runtime efficiency. This is because the speed of execution is crucial in many applications, especially in real-time systems or with large amounts of data. However, in environments with limited resources or significant memory costs, memory efficiency is an important factor.<\/p>\n<\/details>\n[\/sf_box]\n<!-- \/wp:html -->\n\n<!-- wp:paragraph -->\n<p><\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>We want to quantify the runtime of an algorithm. How can we do this?<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Let's take another look at our book search algorithm. We could proceed experimentally and measure the time. To do this, we could search for many different titles in many different sized libraries and measure how long each search takes. We could then try to determine an average value, possibly depending on the size of the library.<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>However, there are uncertainties regarding scalability with this kind of approach. Another example is consistency: we may still be motivated in the first half of the shelf and proceed quickly, but get distracted more often in the second half. Another person, on the other hand, may see the end approaching in the second half and work through the books more quickly. That is a problem. This variability makes it more difficult to compare algorithms, as what works well for us does not necessarily work similarly well for other people.<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>If we implement algorithms in computer programs, we can measure the time our program needs to run for a number of examples. In Python, we can do this with the <code>timeit<\/code> module. However, the core problem is also the same: comparability is not a given. Different computers have different processors that have been optimized for different tasks. As a result, they perform some tasks faster and others slower.<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>It is more objective to count the <strong>number of steps<\/strong> that we, or our computer programs, need until the process stops. A step is a single operation that is executed. How many operations are needed is completely independent of the person or computer performing the operation.<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>However, if we want to make a general evaluation based on the required operations, this presents us with further difficulties because the number of steps varies, for example, based on what book we are looking for. In our book search example, we could assign each possible book title a probability of being searched for and then weight the number of steps required per title with this probability. &nbsp;<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>An approach like this is unnecessarily time-consuming because it gives a very accurate estimate of the runtime. However, we are primarily interested in finding out how well algorithms work on very large data sets. To be precise, we aren't actually necessarily interested in how well an algorithm works, but rather how poorly it works in the worst case. What is the maximum time we have to wait for a Google search query?<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>A different approach has therefore become established: considering the <strong>asymptotic runtime<\/strong> for the worst case. This gives us an upper limit for how long the algorithm would take in the most difficult cases. It helps us to evaluate algorithms in a way that is independent of specific inputs or subjective weightings. We call the asymptotic view of runtime <em>time complexity<\/em>.<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The notation for the limit value behavior of an algorithm in the worst case is the <em>Big O notation<\/em>. We will get to know it in more detail in the following exercise.<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:html -->\n<p>[sf_box type=\"merke\"]<\/p>\n<p><strong>Remember:<\/strong><\/p>\n<ul>\n<li>Finite text, executability, a finite number of steps and a finite amount of memory are the minimum requirements for an instruction to be an algorithm.<\/li>\n<li>The asymptotic consideration of the required steps is called time complexity.<\/li>\n<li>The big O notation is the notation for time complexity in the worst case.<\/li>\n<\/ul>\n<p>&nbsp;<\/p>\n<p>[\/sf_box]<\/p>\n<!-- \/wp:html -->\n\n<!-- wp:paragraph -->\n<p><\/p>\n<!-- \/wp:paragraph -->",
    "post_title": "Introduction to Algorithms",
    "post_excerpt": "",
    "post_status": "publish",
    "comment_status": "closed",
    "ping_status": "closed",
    "post_password": "",
    "post_name": "introduction-to-algorithms",
    "to_ping": "",
    "pinged": "",
    "post_modified": "2024-05-03 11:56:00",
    "post_modified_gmt": "2024-05-03 09:56:00",
    "post_content_filtered": "",
    "post_parent": 392855,
    "guid": "https:\/\/datalab.stackfuel.com\/?post_type=item&#038;p=392857",
    "menu_order": 16,
    "post_type": "item",
    "post_mime_type": "",
    "comment_count": "0",
    "filter": "raw",
    "meta": {
        "sf_item_type": "lecture",
        "sf_lecture_type": "text",
        "_edit_lock": "1728290435:4236",
        "_edit_last": "909",
        "sf_invisibility_setting": "0"
    }
}