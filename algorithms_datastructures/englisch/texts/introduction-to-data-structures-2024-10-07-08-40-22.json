{
    "ID": 392860,
    "post_author": "909",
    "post_date": "2024-05-03 11:58:00",
    "post_date_gmt": "2024-05-03 09:58:00",
    "post_content": "<!-- wp:paragraph -->\n<p>Duration: approx. 15 minutes<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>As you already know, Python is a high-level programming language. Python code is similar to our language and way of thinking. This is what makes the language so easy for us to use and allows us to focus on solving analytical problems. &nbsp;<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>On the one hand, this is very practical. On the other hand, Python hides many details and complexities of the hardware. When we write Python code, for example, we usually don't care how our data is arranged on the hardware. Instead, we use built-in data types such as <code>list<\/code>, <code>dict<\/code>, <code>tuple<\/code> or <code>set<\/code>. These provide us with a lot of functionality: &nbsp;With <code>my_list.sort()<\/code> we can sort a <code>list<\/code> object and with <code>my_set.union(other_set)<\/code> we can union two sets.<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>These operations are nothing other than algorithms. Remember: an algorithm is a series of clearly defined instructions that are executed to perform a specific task. If we sort the list elements in ascending or descending order using <code>my_list.sort()<\/code>, a series of comparison and exchange steps are carried out in the background. What time complexities do <code>my_list.sort()<\/code> or <code>my_set.union()<\/code> have?<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>This question is not easy to answer. We are missing an important piece of information: we don't know how our data is arranged on the hardware. In other words, we don't know the <strong>data structures<\/strong> of <code>list<\/code>, <code>tuple<\/code>, <code>dict<\/code><em> <\/em>and <code>set<\/code>. So we can't say anything about how efficiently their methods can be implemented.<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Data structures are fundamental concepts in computer science that describe the organization, management and storage of data. They define how data can be accessed and how it can be manipulated. Depending on the application, certain data structures may be more efficient than others.<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>We will look at data structures in this second part of the module. In this text lesson, we will first look at how we can categorize data structures. You will also see that different data structures are suitable for different applications and that we can adapt them to our needs. &nbsp;<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:heading -->\n<h2>Categorization of data structures<\/h2>\n<!-- \/wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Let's first take a look at how data structures can be categorized:<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:html -->\n<a class=\"lightbox\" href=\"\/training-content\/python-programmer\/module-05\/chapter-01\/images\/pyp_ads_t3_ds_categories.png\"><img src=\"\/training-content\/python-programmer\/module-05\/chapter-01\/images\/pyp_ads_t3_ds_categories.png\" height=\"500\"><\/a>\n<!-- \/wp:html -->\n\n<!-- wp:paragraph {\"fontSize\":\"small\"} -->\n<p class=\"has-small-font-size\"><strong>Figure 1<\/strong>: Categorization of data structures.<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>We differentiate between arrays and <em>pointer<\/em>-based data structures.<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Arrays <\/strong>are arranged as contiguous blocks on the memory. This means that they are arranged directly one after the other without interruptions or gaps. They therefore also physically resemble our image of a list. In Python, for example, the <code>list<\/code> data type is implemented as an array. Its elements are created as contiguous blocks in memory. This makes accessing elements in a Python list quite fast, as the location of each element is predictable based on the location of the first element and the position of the desired element in the list.<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>However, in <strong>pointer-based structures<\/strong>, each element has its own place in the memory, and \"pointers\" point to the following element or elements.<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>A common example is something called a <em>linked list<\/em>. Each element here consists of a data value and a pointer that points to the next element. We can imagine it like a scavenger hunt: at each location (element) there is a clue to the solution of the puzzle (the data value) as well as a clue to the next location (pointer). Pointer-based data structures can also be non-linear. One example is the binary tree. Each element here can have two pointers, one to the right child and one to the left child. &nbsp;<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>There are also mixed forms. In Python, for example, <code>dict<\/code> and <code>set<\/code> are implemented as <em>hash tables<\/em>. The basic structure of a hash table is a block, i.e. an array. The individual positions in the array then contain the data, sometimes even several. These can then be organized in pointer-based data structures. If you would like to find out more about hash tables, you can click on the expandable box. &nbsp;<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:html -->\n[sf_box type=\"vertiefung\"]\n<details>\n<summary><strong>Deep dive:<\/strong> Hash tables.<\/summary>\n\n<p>\nYou can imagine a hash table as a list with a fixed length. In contrast to a Python list, users do not specify the order of the elements here. They are assigned to the index positions using a hash function. The hash function is already created in the data structure. For example, a hash function could assign all strings beginning with the letter A to index position 0, those beginning with B to index position 1 and so on. If several elements end up in same index position, this is called a collision.  A hash table must be able to deal with this. One option is to organize the data in a linear data structure. \n\n<\/p>\n\n<\/details>\n[\/sf_box]\n<!-- \/wp:html -->\n\n<!-- wp:paragraph -->\n<p><\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:heading -->\n<h2>The best data structure doesn't exist<\/h2>\n<!-- \/wp:heading -->\n\n<!-- wp:paragraph -->\n<p>There is no such thing as <strong>the<\/strong> best data structure. Different structures are differently suited for certain operations. Let's take a look at a few examples:<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Accessing elements by index is very efficient in an array, but not in a linked list or in a hash table. However, if we want to search for an element by its value - and not by its index - this is usually very easy to manage in a hash table. If, on the other hand, the arrangement of the elements is important to us, hash tables are quite useless. This is also the reason why <code>set<\/code> and <code>dict<\/code> are created as hash tables in Python, while <code>list<\/code> and <code>tuple<\/code> are created as arrays.<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>With the Python <code>set<\/code> data type, the order of the elements does not matter. We cannot sort <code>set<\/code>. However, we can search for and remove elements based on the value and insert additional ones. In a <code>list<\/code>, on the other hand, the order of the elements is essential. We can quickly find elements by index and append new ones to the list.<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>If a data structure manages the elements in an arrangement defined by us, we call this a <strong>sequential data structure<\/strong>. An array a sequential data structure. If the elements are arranged differently, as in a hash table, we call this a <strong>set structure<\/strong>.<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>A linked list is also a sequential data structure. It only has one relatively unknown representative in Python, <code>collections.deque<\/code>, as the built-in data types such as <code>list<\/code> and <code>tuple<\/code> are very useful for the vast majority of applications. Nevertheless, it has advantages in some situations. In the following exercises, we will look at a scenario where it is superior to the array in terms of the time complexity of its most important methods.<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>We will also implement a non-linear pointer-based data structure, a binary tree. Binary trees have a hierarchical structure and therefore have no fixed order at first. However, when we run through them, we always adhere to a certain order. In principle, the binary tree can therefore manage data sequentially. However, binary trees show their advantages in typical set operations, such as searching for values or merging sets. We will look at a scenario that requires a set structure.<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:heading -->\n<h2>Data structures are an abstract concept<\/h2>\n<!-- \/wp:heading -->\n\n<!-- wp:paragraph -->\n<p>So there is no such thing as the best data structure. To be precise, there is not even just<strong> one<\/strong> array, <strong>one<\/strong> linked list or<strong> one<\/strong> hash table. These terms refer to concepts of how data can be organized, stored and manipulated. We should understand them as blueprints or sketches and not as finished, concrete structures.<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Although <code>list<\/code> and <code>tuple<\/code> are both implemented as arrays in Python, they have very different functionalities. Unlike the Python list, the Python tuple is not mutable, so we cannot add, remove or overwrite elements.<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Data structures can have very different characteristics. So, it isn't possible to say in general terms how suitable or efficient a data structure is for an operation. However, we can understand the basic characteristics and properties of data structures and ask ourselves: How should it be implemented in order to handle our requirements optimally?<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>So, in the following practical exercise, we won't implement <strong>a <\/strong>linked list, but a form that fits our scenario well. We will think about which methods we need and how we can implement them as efficiently as possible. We will see: Sometimes an additional attribute in our data structure class can make our operations much more efficient.<\/p>\n<!-- \/wp:paragraph -->\n\n<!-- wp:html -->\n[sf_box type=\"merke\"]\n<strong>Remember:<\/strong>\n<ul>\n<li>\nData structures are a concept of how data can be organized, stored and manipulated. <\/li>\n<li>The array stores data elements as a block. Pointer-based data structures use pointers to refer to the following element or elements.   <\/li>\n<li>The choice of data structure should correspond to the needs of the specific application. In particular, we distinguish between sequential data structures and set structures.  <\/li>\n<li> The concrete implementation of the same data structure can be designed very differently.<\/li>\n\n\n<\/ul>\n\n[\/sf_box]\n<!-- \/wp:html -->",
    "post_title": "Introduction to Data Structures",
    "post_excerpt": "",
    "post_status": "publish",
    "comment_status": "closed",
    "ping_status": "closed",
    "post_password": "",
    "post_name": "introduction-to-data-structures",
    "to_ping": "",
    "pinged": "",
    "post_modified": "2024-05-03 11:57:00",
    "post_modified_gmt": "2024-05-03 09:57:00",
    "post_content_filtered": "",
    "post_parent": 392855,
    "guid": "https:\/\/datalab.stackfuel.com\/?post_type=item&#038;p=392860",
    "menu_order": 35,
    "post_type": "item",
    "post_mime_type": "",
    "comment_count": "0",
    "filter": "raw",
    "meta": {
        "sf_item_type": "lecture",
        "_edit_lock": "1728290413:4236",
        "_edit_last": "909",
        "sf_lecture_type": "text",
        "sf_invisibility_setting": "0",
        "sf_training_duration": null
    }
}